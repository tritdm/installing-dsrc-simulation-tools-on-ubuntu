
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Launching and Debugging</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/omnetpp.css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Qtenv Graphical Runtime Environment" href="qtenv.html" />
    <link rel="prev" title="C++ Development" href="cpp-development.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <section id="launching-and-debugging">
<h1>Launching and Debugging</h1>
<section id="introduction">
<h2>Introduction</h2>
<p>The OMNeT++ IDE lets you execute single simulations and simulation batches, and also to debug and, to some extent,
profile simulations. You can choose whether you want the simulation to run in graphical mode (using <span class="guilabel">Qtenv</span>)
or in console (using <span class="guilabel">Cmdenv</span>); which simulation configuration and run number to execute; whether to record an
eventlog or not; and many other options.</p>
<p>When running simulation batches, you can specify the number of processes allowed to run in parallel, so you can take
advantage of multiple processors or processor cores. The progress of the batch can be monitored, and you can also kill
processes from the batch if needed. Batches are based on the parameter study feature of INI files; you can
read more about it in the OMNeT++ Simulation Manual.</p>
<p>Debugging support comes from the Eclipse C/C++ Development Toolkit (CDT), and beyond the basics (single-stepping, stack
trace, breakpoints, watches, etc.) it also offers you several conveniences and advanced functionality such as inspection
tooltips, conditional breakpoints and so on. Debugging with CDT also has extensive literature on the Internet. Currently
CDT uses the GNU Debugger (gdb) as the underlying debugger.</p>
<p>Profiling support is based on the <strong class="command">valgrind</strong> program, <a class="reference external" href="http://valgrind.org">http://valgrind.org</a>. Valgrind is a suite of tools for
debugging and profiling on Linux. It can automatically detect various memory access and memory management bugs, and
perform detailed profiling of your program. Valgrind support is brought into the OMNeT++ IDE by the Linux Tools Project
of Eclipse.</p>
</section>
<section id="launch-configurations">
<h2>Launch Configurations</h2>
<p>Eclipse, and thus the IDE as well, uses <em>launch configurations</em> to store particulars of the program to be
launched: what program to run, the list of arguments and environment variables, and other options. Eclipse and its C/C++
Development Toolkit (CDT) already comes with several types of launch configurations (e.g. “C/C++ Application”), and the
IDE adds <span class="guilabel">OMNeT++ Simulation</span>. The same launch configuration can be used with the <span class="guilabel">Run</span>,
<span class="guilabel">Debug</span> and <span class="guilabel">Profile</span> buttons alike.</p>
</section>
<section id="running-a-simulation">
<h2>Running a Simulation</h2>
<section id="quick-run">
<h3>Quick Run</h3>
<p>The easiest way to launch a simulation is by selecting a project, folder, ini or NED file in <span class="guilabel">Project
Explorer</span>, and clicking the <span class="guilabel">Run</span> button on the toolbar. This will create a suitable launch configuration
(possibly after asking a few questions to clarify what you want to run) if one does not exist already. Instead of the
<span class="guilabel">Run</span> button, you can also choose the <span class="menuselection">Run As ‣ OMNeT++ Simulation</span> from the item’s context
menu.</p>
<p>The details:</p>
<ul class="simple">
<li><p>If a folder is selected and it contains a single INI file, the IDE will use this file to start the simulation.</p></li>
<li><p>If an INI file is selected, it will be used during the launch as the main INI file for the simulation.</p></li>
<li><p>If a NED file is selected which contains a network definition, the IDE will scan for INI files in the active projects
and will try to find a configuration that allows this network to start.</p></li>
</ul>
</section>
<section id="the-run-configurations-dialog">
<h3>The Run Configurations Dialog</h3>
<p>Launch configurations can be managed in the <span class="guilabel">Run Configurations</span> dialog. (Two further dialogs,
<span class="guilabel">Debug Configurations</span> and <span class="guilabel">Profile Configurations</span> are very similar, and allow you to manage
debugging/profiling aspects of launch configurations).</p>
<p>The <span class="guilabel">Run Configurations</span> can be opened in various ways: via the main menu (<span class="menuselection">Run ‣ Run
Configurations</span>); via the context menu item of a project, folder or file (<span class="menuselection">Run As ‣ Run
Configurations</span>); via the green <span class="guilabel">Run</span> toolbar button (<span class="guilabel">Run Configurations</span> item of its
attached menu, or by Ctrl-clicking any other menu item or the toolbar button itself).</p>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="../_images/Launch-RunProject.png"><img alt="../_images/Launch-RunProject.png" src="../_images/Launch-RunProject.png" style="width: 30%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 51 </span><span class="caption-text">One way of opening the <span class="guilabel">Run Configurations</span> dialog</span></p>
</figcaption>
</figure>
</section>
<section id="creating-a-launch-configuration">
<h3>Creating a Launch Configuration</h3>
<p>OMNeT++ IDE adds a new Eclipse launch configuration type, <span class="guilabel">OMNeT++ Simulation</span>, that supports launching
simulation executables. To create a new run configuration, open the <span class="guilabel">Run Configurations</span> dialog. In the
dialog, select <span class="guilabel">OMNeT++ Simulation</span> from the tree, and click the <span class="guilabel">New launch configuration</span> icon in
the top-left corner. A blank launch configuration is created; you can give it a name at the top of the form that
appears.</p>
<figure class="align-default" id="id2">
<a class="reference internal image-reference" href="../_images/Launch-RunDialog.png"><img alt="../_images/Launch-RunDialog.png" src="../_images/Launch-RunDialog.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 52 </span><span class="caption-text">The Simulation Launcher</span></p>
</figcaption>
</figure>
<p>The <span class="guilabel">Main</span> tab of the configuration dialog was designed to make the launching of simulations as easy as
possible. The only required field is <span class="guilabel">Working directory</span>; all others have defaults. If you only select the
working directory and the simulation program, it will start the first configuration from the <code class="file docutils literal notranslate"><span class="pre">omnetpp.ini</span></code> file in the
specified working directory.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Hover your mouse above the controls in this dialog and you will receive tooltip help for the selected control.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <span class="guilabel">Launch</span> dialog will try to figure out your initial settings automatically. If you select an INI file
in the <span class="guilabel">Project Explorer View</span>, or the active editor contains an INI file before launching the
<span class="guilabel">Run</span> dialog, the INI file and working directory field will be automatically populated for you. The dialog
will try to guess the executable name based on the settings of your current open projects.</p>
</div>
<ul>
<li><p><span class="guilabel">Executable</span>: You must set the name of the simulation executable here. This is a workspace path. You may
use the <span class="guilabel">Browse</span> button to select the executable directly. If your project output is a shared library,
select <span class="guilabel">opp_run</span>; it will cause the IDE to use the <strong class="command">opp_run</strong> or the <strong class="command">opp_run_dbg</strong> helper executable
with the <code class="docutils literal notranslate"><span class="pre">-l</span></code> option to run the simulation. Make sure that the <span class="guilabel">Dynamic Libraries</span> field in the advanced
section contains the libraries you want to load.</p></li>
<li><p><span class="guilabel">Working directory</span>: Specifies the working directory of the simulation program. This is a workspace path.
Note that values in several other fields in the dialog are treated as relative to this directory, so changing the
working directory may invalidate or change the meaning of previously selected entries in other fields of the dialog.</p></li>
<li><p><span class="guilabel">Initialization file(s)</span>: You should specify one or more INI files that will be used to launch the
simulation. The default is <code class="file docutils literal notranslate"><span class="pre">omnetpp.ini</span></code>. Specifying more than one file (separated by space) will cause the
simulation to load all those files in the specified order.</p></li>
<li><p><span class="guilabel">Config name</span>: Once you specify a legal INI file, the box will present all of the Config sections in that
file. In addition, it will display the description of that section and the information regarding which Config section
is extended by this section. You may select which Configuration should be launched.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The working directory and the INI file must contain valid entries before trying to set this option.</p>
</div>
</li>
<li><p><span class="guilabel">Runs</span>: It is possible to specify which run(s) must be executed for the simulation. An empty field
corresponds to all runs. You can specify run numbers or a filter expression that refers to iteration variables. Use
the comma and .. to separate the run numbers; for example, 1,2,5..9,20 corresponds to run numbers 1,2,5,6,7,8,9,20.
It is also possible to specify run filters, which are boolean expression involving constants and iteration variables
(e.g. <code class="docutils literal notranslate"><span class="pre">$numHosts&gt;5</span> <span class="pre">and</span> <span class="pre">$numHosts&lt;10</span></code>). Running several simulations in this manner is called batch
execution.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If the executable name and the INI file were already selected, hover the mouse above the field to get the list of
matching runs.</p>
</div>
</li>
<li><p><span class="guilabel">User interface</span>: You can specify which UI environment should be used during execution. The dialog offers
<span class="guilabel">Cmdenv</span> (command-line UI) and <span class="guilabel">Qtenv</span> (Qt-based GUI). If you have a custom user interface, its
name can also be specified here. Make sure that the code of the chosen UI library is available (linked into the
executable/library or loaded dynamically).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Batch execution and progress feedback during simulation are only supported when using <span class="guilabel">Cmdenv</span>.</p>
</div>
</li>
<li><p><span class="guilabel">Allow multiple processes</span>: With batch execution, it is possible to tell the launcher to keep two or more
simulations running at a time or to start a new simulation process after a certain number of runs executed. This way
you can take advantage of multiple CPUs or CPU cores. You can set the number of CPUs to use and the number of runs to
execute in a single process.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use this option only if your simulation is CPU-limited and you have enough physical RAM to support all of the
processes at the same time. Do not set it higher than the number of physical processors or cores you have in your
machine.</p>
</div>
</li>
<li><p><span class="guilabel">Simulation time limit</span> and <span class="guilabel">CPU time limit</span> can be set also to limit the runtime length if the
simulation from the launch dialog in case those were not set from the INI file.</p></li>
<li><p><span class="guilabel">Output options</span>: Various options can be set regarding simulation output. These checkboxes may be in one of
three states: checked (on), unchecked (off), and grayed (unspecified). When a checkbox is the grayed state, the
launcher lets the corresponding configuration option from the INI file to take effect.</p></li>
<li><p>Clicking on the <span class="guilabel">More &gt;&gt;&gt;</span> link will reveal additional controls.</p></li>
<li><p><span class="guilabel">Dynamic libraries</span>: A simulation may load additional DLLs or shared libraries before execution or your
entire simulation may be built as a shared library. The <span class="guilabel">Browse</span> button is available to select one or more
files (use <kbd class="kbd docutils literal notranslate">Ctrl</kbd> + click for multiple selection). This option can be used to load simulation code (i.e. simple
modules), user interface libraries, or other extension libraries (scheduler, output file managers, etc.). The special
macro <code class="docutils literal notranslate"><span class="pre">${opp_shared_libs:/workingdir}</span></code> expands to all shared libraries provided by the current project or any other
project on which you currently depend.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If your simulation is built as a shared library, you must use the <strong class="command">opp_run</strong> stub executable to start it.
<strong class="command">opp_run</strong> is basically an empty OMNeT++ executable which understands all command line options, but does
not contain any simulation code.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you use external shared libraries (i.e. libraries other than the ones provided by the current open projects or
OMNeT++ itself), you must ensure that the executable part has access to the shared library. On Windows, you must
set the <code class="docutils literal notranslate"><span class="pre">PATH</span></code>, while on Linux and Mac you must set the <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> to point to the directory where the
DLLs or shared libraries are located. You can set these variables either globally or in the
<span class="guilabel">Environment</span> tab in the <span class="guilabel">Launcher Configuration Dialog</span>.</p>
</div>
</li>
<li><p><span class="guilabel">NED Source Path</span>: The directory or directories where the NED files are read from.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The variable <code class="docutils literal notranslate"><span class="pre">${opp_ned_path:/workingdir}</span></code> refers to an automatically computed path (derived from project
settings). If you want to add additional NED folders to the automatically calculated list, use the
<code class="docutils literal notranslate"><span class="pre">${opp_ned_path:/workingdir}:/my/additional/path</span></code> syntax.</p>
</div>
</li>
<li><p><span class="guilabel">Image path</span>: A path that is used to load images and icons in the model.</p></li>
<li><p><span class="guilabel">Additional arguments</span>: Other command line arguments can be specified here and will be passed to the
simulation process.</p></li>
<li><p><span class="guilabel">Build before launch</span>: This section allows you to configure the behavior of automatic build before
launching. Build scope can be set either to build <span class="guilabel">this project and all its dependencies</span>, <span class="guilabel">this
project only</span> or we can turn of autobuild before launch. Active configuration switching on build can be also
configured here (<span class="guilabel">Ask</span>, <span class="guilabel">Switch</span>, <span class="guilabel">Never switch</span>.)</p></li>
</ul>
<section id="related-command-line-arguments">
<h4>Related Command-Line Arguments</h4>
<p>Most settings in the dialog simply translate to command-line options to the simulation executable. This is summarized in
the following list:</p>
<ul class="simple">
<li><p>Initialization files: maps to multiple <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">&lt;inifile&gt;</span></code> options</p></li>
<li><p>Configuration name: adds a <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">&lt;configname&gt;</span></code> option</p></li>
<li><p>Run number: adds a <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">&lt;runnumber/filter&gt;</span></code> option</p></li>
<li><p>User interface: adds a <code class="docutils literal notranslate"><span class="pre">-u</span> <span class="pre">&lt;userinterface&gt;</span></code> option</p></li>
<li><p>Dynamically loaded libraries: maps to multiple <code class="docutils literal notranslate"><span class="pre">-l</span> <span class="pre">&lt;library&gt;</span></code> options</p></li>
<li><p>NED Source Path : adds a <code class="docutils literal notranslate"><span class="pre">-n</span> <span class="pre">&lt;nedpath&gt;</span></code> option</p></li>
</ul>
</section>
</section>
<section id="debug-vs-release-launch">
<h3>Debug vs. Release Launch</h3>
<p>The launcher automatically decides whether the release or debug build of the model should be started. When running,
release mode binaries are used automatically. For debugging, debug builds are started (i.e. those where the binary ends
with <code class="docutils literal notranslate"><span class="pre">_dbg</span></code> suffix.) Before starting the simulation, the launcher ensures that the binary is up to date and triggers a
build process (and changes also the active configuration) if necessary.</p>
</section>
</section>
<section id="batch-execution">
<h2>Batch Execution</h2>
<p>OMNeT++ INI files allow you to run a simulation several times with different parameters. You can specify loops or
constraint conditions for specific parameters.</p>
<figure class="align-default" id="id3">
<a class="reference internal image-reference" href="../_images/Launch-BatchRun.png"><img alt="../_images/Launch-BatchRun.png" src="../_images/Launch-BatchRun.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 53 </span><span class="caption-text">Iteration variable in the INI file</span></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Batch running is supported only in the command line environment.</p>
</div>
<p>If you create an INI file configuration ([Config] section) with one or more iteration variables, you will be able to run
your simulations to explore the parameter space defined by those variables. Practically, the IDE creates the Cartesian
product from these variables and assigns a run number to each product. It is possible to execute one, several or all
runs of the simulation by specifying the <span class="guilabel">Run number</span> field in the <span class="guilabel">Run Dialog</span>. You can specify a
single number (e.g. <code class="docutils literal notranslate"><span class="pre">3</span></code>), a combination of several numbers (e.g. <code class="docutils literal notranslate"><span class="pre">2,3,6,7..11</span></code>), all run numbers (using <code class="docutils literal notranslate"><span class="pre">*</span></code>) or boolean
expressions using contstants and iteration variables (e.g. <code class="docutils literal notranslate"><span class="pre">$numHosts&gt;5</span> <span class="pre">and</span> <span class="pre">$numHosts&lt;10</span></code>.)</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you already have specified your executable, chosen the configuration which should be run and selected the command
line environment, you may try to hover over the <span class="guilabel">Run Number</span> field. This will give you a description of the
possible runs and how they are associated with the iteration variable values (the tooltip is calculated by executing
the simulation program with the <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">Configuration</span> <span class="pre">-G</span></code> options in command line mode).</p>
</div>
<figure class="align-default" id="id4">
<a class="reference internal image-reference" href="../_images/Launch-BatchRun2.png"><img alt="../_images/Launch-BatchRun2.png" src="../_images/Launch-BatchRun2.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 54 </span><span class="caption-text">Iteration loop expansion in a tooltip</span></p>
</figcaption>
</figure>
<p>If you have a multi-core or multi-processor system and have ample memory, you may try to set the <span class="guilabel">Processes to
run parallel</span> field to a higher number. This will allow the IDE to start more simulation processes in parallel,
resulting in a much lower overall simulation time for the whole batch.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Be aware that you need enough memory to run all these processes in parallel. We recommend using this feature only if
your simulation is CPU-bound. If you do not have enough memory, your operating system may start to use virtual
memory, dramatically decreasing the overall performance.</p>
</div>
</section>
<section id="debugging-a-simulation">
<h2>Debugging a Simulation</h2>
<p>The OMNeT++ IDE integrates with the CDT (C/C++ Development Tooling) of Eclipse which also includes debugging support.
The CDT debugger UI relies on <strong class="command">gdb</strong> for doing the actual work.</p>
<section id="starting-a-debug-session">
<h3>Starting a Debug Session</h3>
<p>Launching a simulation in debug mode is very similar to running it (see previous sections), only you have to select the
<span class="guilabel">Debug</span> toolbar icon or menu item instead on <span class="guilabel">Run</span>. The same launch configurations are used for
debugging that for running, that is, if you open the <span class="guilabel">Debug Configurations</span> dialog, you will see the same
launch configurations as in the <span class="guilabel">Run</span> dialog. The launcher is automatically using the debug build of the model
(i.e. the executable that has a <code class="docutils literal notranslate"><span class="pre">_dbg</span></code> suffix.) The dialog will have extra tab pages where you can configure the
debugger and other details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you have problems with starting the debug session, check whether:</p>
<ul class="simple">
<li><p>your executable is built with debug information,</p></li>
<li><p>you can run the same executable without problem (using the same launch configuration, but with adding a <code class="docutils literal notranslate"><span class="pre">_dbg</span></code>
suffix to the executable name), and</p></li>
<li><p>the debugger type is set properly on the <span class="guilabel">Debugger</span> tab of the <span class="guilabel">Launch</span> dialog.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Batch (and parallel) execution is not possible in this launch type, so you may specify only a single run number.</p>
</div>
</section>
<section id="using-the-debugger">
<h3>Using the Debugger</h3>
<p>The CDT debugger provides functionality that can be expected from a good C/C++ debugger: run control (run, suspend, step
into, step over, return from function, drop to stack frame); breakpoints (also conditional and counting breakpoints);
watchpoints (a.k.a. expression breakpoints, breakpoints that stop the execution whenever the value of a given expression
changes); watching and inspecting variables; and access to machine-level details such as disassembly, registers and
memory.</p>
<p>Source code is shown in the editor area; additional information and controls are displayed in various Views:
<span class="guilabel">Debug</span>, <span class="guilabel">Breakpoints</span>, <span class="guilabel">Expressions</span>, <span class="guilabel">Variables</span>, <span class="guilabel">Registers,
Memory</span>, etc.</p>
<p>CDT’s conversation with gdb can also be viewed, in the appropriate pages of the <span class="guilabel">Console View</span>. (Click the
<span class="guilabel">Display Selected Console</span> icon, and choose <span class="guilabel">gdb</span> or <span class="guilabel">gdb traces</span> from the menu.)</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>One little tip that we found useful: if you have a pointer in the program that actually points to an array (of
objects, etc), you can have it displayed as an array, too. In <span class="guilabel">Variables</span>, right-click the variable and
choose <span class="guilabel">Display As Array</span> from the menu. You will be prompted for a start index and the number of
elements to display.</p>
</div>
<p>More information on the debugger is available in the CDT documentation, which is part of the IDE’s Help system. See
<span class="guilabel">C/C++ Development User Guide</span>, chapter <span class="guilabel">Running and debugging projects</span>.</p>
</section>
<section id="pretty-printers">
<h3>Pretty Printers</h3>
<p>Many programs contain data structures whose contents is difficult to comprehend by looking at “raw” variables in the
program. One example is the <code class="docutils literal notranslate"><span class="pre">std::map&lt;T&gt;</span></code> class, which is essentially a dictionary but implemented with a binary tree,
so it is practically impossible to figure out with a C++ debugger what data a concrete map instance contains.</p>
<p>The solution gdb offers to this problem is pretty printers. Pretty printers are Python classes that gdb invokes to
transform some actual data structure to something that is easier for humans to understand. The <code class="docutils literal notranslate"><span class="pre">*.py</span></code> files that
provide and register these pretty printers are usually loaded via gdb’s startup script, <code class="docutils literal notranslate"><span class="pre">.gdbinit</span></code> (or some
<code class="docutils literal notranslate"><span class="pre">.gdbinit.py</span></code> script, because gdb allows startup scripts to be written in Python, too).</p>
<p>The OMNeT++ IDE comes with pretty printers for container classes in the standard C++ library (<code class="docutils literal notranslate"><span class="pre">std::map&lt;T&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;T&gt;</span></code>, etc.) and also for certain OMNeT++ data types, for example <code class="docutils literal notranslate"><span class="pre">simtime_t</span></code>. These scripts are located
under <code class="docutils literal notranslate"><span class="pre">misc/gdb/</span></code> in the OMNeT++ root directory. The IDE also supports project-specific pretty printers: if the
debugged project’s root folder contains a <code class="docutils literal notranslate"><span class="pre">.gdbinit.py</span></code> file, it will be loaded by gdb. (The project’s <code class="docutils literal notranslate"><span class="pre">.gdbinit.py</span></code>
can then load further Python scripts, e.g. from an <code class="docutils literal notranslate"><span class="pre">etc/gdb/</span></code> folder of the project.)</p>
<p>Pretty printer loading works in the following way. The IDE invokes gdb with <code class="docutils literal notranslate"><span class="pre">misc/gdb/gdbinit.py</span></code> as startup script
(for new launch configurations, the <span class="guilabel">GDB command file</span> field on the <span class="guilabel">Debugger</span> tab is set to
<code class="docutils literal notranslate"><span class="pre">${opp_root}/misc/gdb/gdbinit.py</span></code>). This script loads the pretty printers under <code class="docutils literal notranslate"><span class="pre">misc/gdb</span></code>, and also the
project-specific pretty printers.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you want to write your own pretty printers, refer to the gdb documentation. It is available online e.g. here:
<a class="reference external" href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>
</div>
<p>Some pretty-printers may occasionally interfere with the debugged program (especially if the program’s state is already
corrupted by earlier errors), so at times it may be may be useful to temporarily turn off pretty printers. To prevent
pretty printers from being loaded for a session, clear the <span class="guilabel">GDB command file</span> setting in the launch
configuration. To disable them for a currently active debug session, switch to the <span class="guilabel">gdb</span> page in the
<span class="guilabel">Console</span>, and enter the following gdb command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">disable</span> <span class="n">pretty</span><span class="o">-</span><span class="n">printer</span> <span class="k">global</span>
</pre></div>
</div>
<p>Or, to only disable OMNeT++-specific pretty printers (but leave the standard C++ library printers on):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">disable</span> <span class="n">pretty</span><span class="o">-</span><span class="n">printer</span> <span class="k">global</span> <span class="n">omnetpp</span><span class="p">;</span><span class="o">.*</span>
</pre></div>
</div>
</section>
</section>
<section id="just-in-time-debugging">
<h2>Just-in-Time Debugging</h2>
<p>The OMNeT++ runtime has the ability to launch an external debugger and have it attached to the simulation process. One
can configure a simulation to launch the debugger immediately on startup, or when an error (runtime error or crash)
occurs. This just-in-time debugging facility was primarily intended for use on Linux.</p>
<p>To turn on just-in-time debugging, set the <code class="docutils literal notranslate"><span class="pre">debugger-attach-on-startup</span></code> or <code class="docutils literal notranslate"><span class="pre">debugger-attach-on-error</span></code> configuration
option to <code class="docutils literal notranslate"><span class="pre">true</span></code>. You can do so by e.g. adding the appropriate line to <code class="file docutils literal notranslate"><span class="pre">omnetpp.ini</span></code>, or specifying
<code class="docutils literal notranslate"><span class="pre">--debugger-attach-on-startup=true</span></code> in the <span class="guilabel">Additional arguments</span> field in the launch configuration dialog.
It is also possible to configure the debugger command line.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On some systems (e.g. Ubuntu), just-in-time debugging requires extra setup beyond installing external debugger. See
the <a class="reference internal" href="../installguide/index.html#install-guide"><span class="std std-ref">Installation Guide</span></a> for more details.</p>
</div>
</section>
<section id="profiling-a-simulation-on-linux">
<h2>Profiling a Simulation on Linux</h2>
<p>On Linux systems, the OMNeT++ IDE supports executing your simulation using the <span class="guilabel">valgrind</span> program. Running
your program with valgrind allows you to find memory-related issues and programming errors in your code. The simulation
will run in an emulated environment (much slower than normal execution speeds), but valgrind will generate a detailed
report when it finishes. The report is shown in a separate <span class="guilabel">Valgrind View</span> at the end of the simulation run.
The OMNeT++ IDE contains support only for the <code class="docutils literal notranslate"><span class="pre">memcheck</span></code> tool. If you want to use other tools
(<code class="docutils literal notranslate"><span class="pre">cachegrind,</span> <span class="pre">callgrind,</span> <span class="pre">massif</span></code> etc.), you may try to install the full ‘Linux Tools Project’ from the Eclipse
Marketplace.</p>
<p>To start profiling, right-click on your project in the <span class="guilabel">Project Explorer</span> tree and select <span class="menuselection">Profile
As ‣ OMNeT++ Simulation</span>. Valgrind must already be installed on your system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Simulation executes considerably slower than a normal run. Prepare for long run-times or limit the simulation time in
your .INI file. You do not need statistical convergence here, just run long enough that all the code paths are
executed in your model.</p>
</div>
</section>
<section id="controlling-the-execution-and-progress-reporting">
<h2>Controlling the Execution and Progress Reporting</h2>
<p>After starting a simulation process or simulation batch you can keep track of the started processes in the
<span class="guilabel">Debug View</span>. To open the <span class="guilabel">Debug View</span> automatically during launch, check the Show Debug View on
Launch in the run configuration dialog, or select <span class="menuselection">Window ‣ Show View ‣ Other ‣ Debug ‣ Debug</span>.
Select a process and click the terminate button to stop a specific simulation run or use the context menu for more
options to control the process execution.</p>
<figure class="align-default" id="id5">
<a class="reference internal image-reference" href="../_images/Launch-DebugView.png"><img alt="../_images/Launch-DebugView.png" src="../_images/Launch-DebugView.png" style="width: 40%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 55 </span><span class="caption-text">Debug View</span></p>
</figcaption>
</figure>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Place the Debug View in a different tab group than the console so you will be able to switch between the process
outputs and see the process list at the same time.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can terminate all currently running processes by selecting the root of the launch. This will not cancel the whole
batch; only the currently active processes. If you want to cancel the whole batch, open the <span class="guilabel">Progress View</span>
and cancel the simulation batch there.</p>
</div>
<p>Clicking on the process in the <span class="guilabel">Debug View</span> switches to the output of that process in the <span class="guilabel">Console
View</span>. The process may ask for user input via the console, too. Switch to the appropriate console and enter the
requested parameters.</p>
<figure class="align-default" id="id6">
<a class="reference internal image-reference" href="../_images/Launch-ConsoleView.png"><img alt="../_images/Launch-ConsoleView.png" src="../_images/Launch-ConsoleView.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Displaying the output of a simulation process in Console View</span></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, the <span class="guilabel">Console View</span> automatically activates when a process is writing to it. If you are running
several parallel processes, this might be an annoying behavior and might prevent you from switching to the
<span class="guilabel">Progress View</span>. You can switch off the auto-activation by disabling the <span class="guilabel">Show Console When
Standard Out/Error Changes</span> in the <span class="guilabel">Console View</span> toolbar.</p>
</div>
<section id="progress-reporting">
<h3>Progress Reporting</h3>
<p>If you have executed the simulation in the command line environment, you can monitor the progress of the simulation in
the <span class="guilabel">Progress View</span>. See the status line for the overall progress indicator and click on it to open the
detailed progress view. It is possible to terminate the whole batch by clicking on the cancel button in the
<span class="guilabel">Progress View</span>.</p>
<figure class="align-default" id="id7">
<a class="reference internal image-reference" href="../_images/Launch-ProgressView.png"><img alt="../_images/Launch-ProgressView.png" src="../_images/Launch-ProgressView.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">Progress report on four parallel processes</span></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <span class="guilabel">Progress View</span> displays “Waiting for user input”, the simulation is waiting for the user. Switch to
the appropriate console and provide the requested input for the simulation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you need more frequent progress updates, set the <code class="docutils literal notranslate"><span class="pre">cmdenv-status-frequency</span></code> option in your INI file to a lower
value.</p>
</div>
</section>
</section>
</section>


          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;1992-2021, András Varga and OpenSim Ltd..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/userguide/launcher.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>